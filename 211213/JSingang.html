

<script>
/*--
    IEEE 754 :
    IEEE 754는 전기 전자 기술자 협회에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준
    <64비트 부동 소수점 처리>
    비트는 0과 1의 값만을 가짐.
    0과 1을 64비트를 사용하여 천억도 억도 모두 나타냄. 
    1을 나타낼때도 64비트를 모두 사용함.
    비경제적이지만 64비트 부동 소수점 처리를 이용하기 때문에 어쩔 수 없음.

    부동 소수점 처리란?
    123을 123.0으로 처리 

    자바스크립트에서는 정수와 실수를 구분하지 않고 실수로 계산한다. 
    예) 0.12+5에서 5를 5.0으로 변환해서 계산한다. 


    상수
    -변경할 수 없는 값
    -상수 변수 : 상수가 설정된 변수, 자바스크립트는 값을 변경할 수 있으므로 상수 변수는 선언적 의미.
    -상수변수 표기 방법: 코딩관례로 영문 대문자 사용
    ex) var ONE=1;
    변수는 대문자로 선언하면 "값을 바꿀수는 있지만 바꾸지 말아라"라는 개발자들의 선언.
    대문자로 선언된 변수는 되도록이면 바꾸지 말기!!!


    진수
    - 10진수 : 123
    - 16진수 :
        OxFF: 255
        1번째에 숫자 0작성
        2번째에 영문자 x작성
        3번째 이후 : 0~f 작성
        대소문자 구분하지 않음
    OXF는 15
    OX는 16진수를 나타내므로 값이 아니며 A:10, B:11, C:12, D:13, E:14, F:15
    Oxff는 (16*15 + 15) 방법으로 계산
    Oxfff는 (16*16*15) + (16*15) +15로 계산

    - 8진수
        05xx로 시작
    - 2진수 (비트)
        0또는 1의 값만을 가진 비트


    머신러닝 딥러닝에서는 CPU가 아닌 GPU를 사용할때는 2진수를 사용한다. 

    
    데이터타입
    -데이터의 사전적 의미 : 자료
    -숫자타입 : var value=123;
    -문자타입 : var value = "sports";
    -typeof연산자
        :데이터(값) 타입 반환
        :typeof value에 데이터를 작성
    -데이터는 타입을 가짐
        :JS는 데이터를 기준으로 타입을 결정
        :타입을 먼저 선언하고 타입에 맞는 데이터를 할당하지는 않음
        cf) c++이나 JAVA는 타입을 먼저 선언하고 타입에 맞는 데이터를 할당함. but 자바스크립트는 그렇지 않음!!
    */

    var point=123;
    console.log(typeof point);
    point = "책";
    consonle.log(typeof point);

    /* point변수에 123을 할당하면 point변수의 데이터 타입은 number
    다시 point변수에 "책"을 할당하면 point변수의 데이터 타입은 string
    JS는 이처럼 데이터(값)에 따라서 데이터 타입이 결정됨. */


    /* 데이터 타입 분류 (언어타입 / 스펙타입)
        -언어타입 : JS프로그램에서 사용 할 수 있는 타입
        undefined, null, boolean, string, number, object
        
        -스펙(문서)타입 : 언어알고리즘을 위한 타입으로 JS프로그램에서 사용 불가
        Reference, List, Completion, Property Descriptor, Data Blockk, Lexical Environment, Lexical Record 등
        
        
        
    1. Number 타입
        :부호를 (+,-)를 가진 값
        Number 타입의 특수한 3개 값
            # NaN : Not a Number (NaN 역시도 큰틀에서 Number타입에 들어간다.). 프로그램이 죽지않게 하기위해서 
            # Infinity : 양수 무한대
            # -Infinity : 음수 무한대 
            
            
    2. string 타입
        :값을 ""또는 ''사이에 작성
        :최대 문자수 : 2의 53승 -1
        큰따옴표와 작은 따옴표를 같이 사용할 때
        :따옴표안에 숫자를 작성하면 string타입이 됨 
        
        
    3. Undefined 타입 (대문자 U는 타입을 뜻하고 소문자 u는 값을 뜻함)
        :Undefined타입 (U가 대문자)
        cf) undefined는 값 (u가 소문자 일때는 값을 뜻함)
        :변수의 디폴트 값
        :var point;
        :변수를 선언만 한 것으로 undefined가 초깃값으로 설정
        :변수에 undefined 할당 가능
        :변수에 값을 할당하지 않은 것을 나타내는 시맨틱 (즉, 변수를 선언만 한것을 의미함)


    그렇다면 내가 단순히 값을 할당하지 않은것이나, 값에 직접적으로 undefined를 할당한 것이나 결과가 똑같음

    4. Null 타입 (대문자 N은 타입을 뜻하고 소문자 n은 값을 뜻함)
        : 값 null(소문자)
        # null과 undefined 의 차이
        -undefined는 단지 변수만 선언해도 자동적으로 undefined가 실행됨
        -null을 할당해야지만 값이 null이 됨
        -null은 의도적으로 
        값을 할당한 것으로 코드를 수행한 것이 됨.
        
        
    5. Object타입
        : {name:value}형태 
        : 프로퍼xl(property) : name과 value하나를 지칭
        : object는 프로퍼티 집합 
        */

        var point = "책,'123'";
        console.log(point);
        point='책,"123"';
        console.log(point);

        /* 결과값 
        책, '123'
        책, "123"
        작은 따옴표를 표시하려면 큰 따옴표 안에 작은 따옴표를 작성
        큰 따옴표를 표시하려면 작은 따옴표 안에 큰 따옴표를 작성*/

        console.log(typeof 123);
        console.log(typeof "문자열");
        console.log(typeof true);
        console.log(typeof undefined);

        console.log(typeof null);
        console.log(typeof {book: "책"});

        /*  typeof undefined는 undefined가 나오고
        typeof null은 object가 나옴.
        
        이것은 JS의 설계미스 -> ES6에서 이것의 한계를 극복한게 나옴.
        이것은 추후에 다룸 */



        /*
        
        연산자
        -규칙에 따라 계산하여 값을 구함
        -연산자(operator)형태
        +, -, *, /, %, >, >=, === ,<, !==, 콤마, typeof, delete, void, instanceof, in, new
        
        
        표현식(Expression)
        1+2
        var total = 1+2 ;
        var value - total / (2+3);
        표현식을 평가
        표현식을 평가하면 결과가 반환되며 이를 평가결과라고 함.
        
        */
    

        var two = "2";
        var value = 1 + two;
        console.log(value);
        console.log(typeof value);

        var value = 1+5+"ABC";
        console.log(value);

        /* 
        +연산자
        -한쪽이라도 숫자가 아니면 연결함
        1+two를 각각 string으로 인식하고 string으로 연결함. 

        1과 5는 왼쪽에서부터 연산해서 6으로 연산.
        ABC는 string으로 인식하여 연결함.
        */


        /* 
        숫자로 변화
        -연산하기 전에 우선 숫자로 변환
        undefined : NaN
        null : +0
        Boolean : true는 1, false는 0으로 변환
        Number : 변환 전/후가 같음
        string : 값이 숫자이면 숫자로 연산, 단. 더하기(+)만은 연결


        */

        var value;
        console.log(10+value);
        //10과 undefined를 더하면 NaN. NaN도 값임.


        console.log(10 + null); // null은 0으로 변환되어 결과값이 10
        console.log(10 + true);  // true는 1로 변환되어 결과값이 11
        console.log(10 + false);  // false는 0으로 변환되어 결과값이 10 


        /* @@숫자를 문자열로 작성했을때@@
        더하기: 더하기는 값이 숫자라도 타입이 string이면 문자열로 연결
        빼기,곱하기,나누기: 빼기,곱하기,나누기는 문자열로 작성되었어도 숫자로 먼저 변환하여 연산함*/

        console.log(10+"123");    //10123
        console.log(123-"23");      //100

        /* 
        산술연산자
        
        -(빼기)연산자 : string타입이지만, 값이 숫자이면 Number 타입으로 변환하여 계산함
        *(곱하기)연산자 : 숫자값으로 변환 할 수 있으면 변환하여 곱함. 
                        NaN반환 ) 양쪽의 평가결과가 하나라도 숫자가 아닐때
        -소수값이 생기는 경우 처리
        /연산자 : NaN반환 (양쪽의 평과결과가 하나라도 숫자가 아닐 때 / 분모,분자가 모두 0일때)
                분모가 0이면 Infinity반환 / 분자가 0이면 0반환
        */

        console.log(10 * "20");  // 200
        console.log(10 * true);  // 10
        console.log(10 * false);  // 0
        console.log(10 * null);  // 0
        console.log(10 * "A");  //NaN (하나가 숫자가 아니고, 숫자로 변환도 불가능하므로 NaN)

        console.log(2.3*3);         //실행결과 6.8999999999999999995
        console.log(2.3*10*3 /10);      //실행결과 6.9

        /* 2.3 * 3은 6.9로 출력되지 않는다. 
        이는 정상적이며 IEEE 754 유동 소수점 처리 때문이다.
        따라서 오류를 피하고 싶으면 <<실수를 정수로 변환하여 값을 구하고 다시 정수를 실수로 변환>> 하는 것이 정석!  
        */

        console.log( 5 % 2.5 );         //실행결과 0
        console.log( 5 % 2.3 );             //실행결과 0.4000000000000000000036
        console.log((5*10 - (2*2.3*10)) / 10 );         //실행결과 0.4 (IEEE754의 유동 소수점 처리문제 때문에 오차를 피하고 싶다면 실수를 정수로 변환하여 연산후 다시 정수를 실수로 변환해야함.)

        /* 
        단항 + 연산자
        -형태 : +value
        -값을 Number 타입으로 변환
        - +를 더하기로 착각할 수도 있음
        -Number()와 기능이 같음 */

        var value = "7";
        console.log(typeof value);      //string
        console.log(typeof +value);     //number
        console.log(typeof Number(value));      //number

        /*
        단항 - 연산자
        -형태 : -value
        -값의 부호를 바꿈
            : +는 -로, -는 +로 바꿈
        -연살할때만 바꾸고, 원래 값은 바뀌지 않음

        */

        var value = "7";
        console.log(-value);            //결과 : -7                 일시적으로 value값의 부호를 바꿈. 그러나 본질값은 변하지 않음
        console.log(8 + -value);        //결과 : 1                  변화한 부호로 연산을 실시
        console.log(value);             //결과 : 7                  실제로 본래의 값은 변하지 않음

        //가독성이 떨어지기 때문에 소괄호 안에  ( value * -1 ) 형태로 이용하는 것이 가독성이 더욱 높다 


        /* 후치, 전치, 논리 NOT 연산자
        
        1. 후치 ++ 연산자
        형태 : value++
        값을 자동으로 1 증가시킴
        -문장을 수행한 후에 1증가
        -즉, 세미콜론(;) 다음에서 증가
        
        1-1. 후치 -- 연산자
        형태 : value--
        값을 자동으로 1 감소시킴
        -문장을 수행한 후에 1감소
        -즉, 세미콜론(;)다음에 감소

        
        */

        var one = 1;
        var value = one++ +3;
        console.log(value);     //4         one++을 하면 1이 2가 되지만 세미콜론을 지나기 전이므로 문장안에서는 1이 증가하지 않는다. 
        console.log(one);       //2         세미콜론 다음에서는 1이 증가하여 2가 됩니다. 


        var two =2;
        var value = two-- + 3;
        console.log(value);      //5
        console.log(two);       //1

        /*
        
        2. 전치 ++연산자
        형태 : ++value
        값을 자동으로 1 증가시킴
        -문장 안에서 1증가
        -value를 만나는 시점에서 1증가. 
        
        
        2-1. 전치 --연산자
        형태 : --value
        값을 자동으로 1 감소시킴
        -문장안에서 1감소
        -value를 만나는 시점에서 1감소시키고 감소시킨 값을 사용 */

        var one =1;
        var value = ++one +3;
        log(value);     //5         전치 ++연산자는 변수를 만나는 시점에 1을 증가시키고 연산을 수행한다. 

        var two = 2;
        var value= --two + 3;
        console.log(value);
        

        /* !연산자 
        
        형태 : !value
        -표현식 평가 결과를 true, false로 변환한 후
        true이면 false를 false이면 true를 반환
        -원래 값은 바뀌지 않으며 사용할 때만 변환

         */
         
         var value = true;
         console.log(!value);       //false
         console.log(!!"A");        //true  !를 두번쓰면 두번바뀐다. 

         /* 유니코드,UTF
        1. 세계의 모든 문자를 통합하여 코드화
        2. 언어, 이모지 등등
        3. 코드 값을 코드포인트(code point)라고 부름
        4. 0000~FFFF, 10000~1FFF 값에 문자 매핑
        5. 유니코드 컨소시엄 http:www/unicode.org/

        표기방법
        1. u와 숫자 형태 : u0031은 숫자1
        2. JS는 u앞에 역슬래시(\) 작성
        3. 역슬래시(\)를 문자로 표시하려면 역슬래기(\\)2개 작성
        4. ES6에서 표기 방법 추가됨.
        */

        /*  
        >연산자
        1.한쪽이 숫자이고 한쪽이 문자이면 무조건 false
        2. 둘다 문자이면 유니코드 사전 순서로 비교
        3. 문자 하나씩 비교 
        가나다순서대로 유니코드 등록할때 먼저 등록할수록 숫자가 낮음!
        
        */

        console.log("A07" > "A21");
        //A가 같으므로 0과 2를 비교하면 2가 더 커서 false를 반환/ 한번 결정이 되면 다음의 7과 1은 비교하지 않습니다. 
        //코드포인트는 단위별로 비교하고 조건을 만족하면 뒤를 더이상 비교하지 않는다. 


        /* 
        콤마연산자 
        ()연산자
        ||연산자
        &&연산자
        */

       var value, zero = 0, two = 2;
       console.log(value || zero || two);  //0을 제외한 모든 값을 true이지만 0만은 false가 된다.
        //value 변숫값이 undefined이므로 false, zero 변수값이 0이므로 false, two 변수값이 2이므로 true가 되면서 two 변숫값을 반환
        //이때 반환값이 'True'가 아니라 true가 되는 변숫값 반환
        //2가 true이므로 전체비교는 true

        var value, zero = 0;
        console.log(zero || value); //결과값 : undefined
        //이때 value는 undefined, zero는 0인데, 마지막까지 비교하였는데 모두가 false이면 false가 아니라 마지막 변숫값을 반환
        //마지막 변숫값이 value이므로 undefined를 반환

        var one = 1;
        console.log(one === 1 || two ===2);
        //왼쪽의 결과가 true를 반환, 오른쪽은 비교하지 않음. 만약 비교한다면 two변수는 선언도 되지 않았으므로 에러가 발생 

        
        //&&연산자 -> 모두가 true일때는 두개다 비교
        var one = 1, two = 2;
        console.log(one && two);
        //결과값 : 2
        // one의 변수값이 1이므로  true이므로 오른쪽도 비교 , 두개 모두가 true이므로 마지막 변숫값을 반환

        //&&연산자 -> 왼쪽 결과가 false이면 오른쪽값은 비교하지 않음

        var one =1, zero = 0;
        console.log( one && zero && nine);
        ///zero가 false이므로 nine값은 비교하지 않는다. 만약 비교하게 되면 nine은 선언조차 되지 않았으므로 에러가 발생 



        /* 조건연산자, 연산자 우선순위
        조건연산자
        기호: exp ? exp-1 : exp-2
        3항 연산자라고도 함
        exp가 trun이면 exp-1반환 / false이면 exp-2 반환


        연산자 우선순위
        MDN operator precedence
        mozilla사이트의 MDN과 친해지기!!!
        */ 

        /* debugger;
        코딩 중간중간 debugger를 넣으면 테스트 코딩 가능
        */


        /* while
        형태 : while(문장)
        표현식의 평가 결과가 false가 될때까지
        false가 되도록 조치를 취하지 않으면 무한반복
        
        do 문장 while
        형태 : do 문장 while (표현식)
        처리방법은 while문과 같으나 do 문을 먼저 실행
        
        for( 초깃값opt; 비교opt; 증감opt)
        모두가 opt인 만큼 초깃값, 비교, 증감 생략가능함
        2번째의 비교 표현식의 평가결과가 true인 동안 문장을 반복 실행
        순서는 증감 opt -> 비교opt순서로 가게됨 / 초기값은 맨 처음 딱한번만 가게되고 그 뒤로는 절대 가지 않는다.


        */

        for (var k = 0; k < 3;) {
            log(k);
            k++;
        };
        //for문에서 증감opt생략한 형태. 블록내에서 k변숫값을 증가시킴

        var k=0;
        for (; k<3;) {
            log(k);
            k++;
        }
        
        //for문에서 초깃값, 증감 모두 생략한 형태. 블록내/외에서 조건을 대신 넣어줌. 


        //조건 3가지 모두생략가능
        var k=0;
        for (;;) {
            log(l);
            if (k===2) {
                break;
            };
            k++;
        };

        for (var k=0; k<3; k++) {
            if (k===1) {
                break
                log("k === 1");
            };
            console.log(k);
        };
        //break 뒤에 세미콜론(;)없으니까 계속 실행되냐? 아님. 세미콜론을 자동으로 첨부한다. 


</script>